#!/bin/bash
set -euo pipefail

# -----------------------------------------------------------------------------
# Use this script to easily setup
# - FPC (Free Pascal Compiler)
# - and CGE (Castle Game Engine)
#
# See README.md within our repository
# (https://github.com/castle-engine/castle-fpc/ ) for details and examples.
# -----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# bash functions below.
# do_xxx functions are executed in order by the main script,
# other functions are helpers used by do_xxx functions.

# Preserve variable named $1 for future CI steps.
# Uses $GITHUB_ENV (if defined, in GitHub Actions) and to setup_castle_engine_env.sh.
preserve_variable_for_future_ci_steps()
{
  VAR=$1
  shift 1

  if [ -n "${GITHUB_ENV:-}" ] ; then
    if [ -d "`dirname \"${GITHUB_ENV}\"`" ] ; then
      echo "$VAR=${!VAR}" >> "${GITHUB_ENV}"
    else
      echo "Warning: GITHUB_ENV is defined (${GITHUB_ENV}), but the directory it points to doesn't exist."
      echo "  Possible reason: you are within GitHub Actions job and use pguyot/arm-runner-action, where GITHUB_ENV refers to outer machine (like ubuntu-latest), not the ARM runner machine."
      echo "  Ignoring GITHUB_ENV."
    fi
  fi

  # Add export and surround with ', to allow "source setup_castle_engine_env.sh" reliably
  echo "export $VAR='${!VAR}'" >> "${DEFINES_FILE}"
}

# Prepend path to $PATH for this script and future CI steps.
# For Windows, DIR should be in native format (with : for drive separator).
prepend_to_path()
{
  DIR=$1
  shift 1

  if which cygpath > /dev/null 2>&1; then
    DIR_UNIX="`cygpath --unix \"${DIR}\"`"
  else
    DIR_UNIX="${DIR}"
  fi

  # change current shell
  export PATH="${DIR_UNIX}:${PATH}"

  # extend setup_castle_engine_env.sh
  echo "export PATH=\"${PATH}\"" >> "${DEFINES_FILE}"

  # extend GITHUB_PATH, if GITHUB_PATH defined and valid.
  # Following https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-commands#adding-a-system-path
  if [ -n "${GITHUB_ENV:-}" ] ; then
    if [ -d "`dirname \"${GITHUB_ENV}\"`" ] ; then
      echo "${DIR}" >> $GITHUB_PATH
    fi
  fi

  # Never do this:
  # preserve_variable_for_future_ci_steps PATH
  # See github_actions_prepend_path.md for explanation.
}

# Parse command-line arguments. Pass here arguments to this script.
do_parse_arguments()
{
  # in case some system defines $OS or $CPU, like Windows on GHA has OS=Windows_NT
  unset OS
  unset CPU

  INSTALL_FPC='true'
  INSTALL_LAZARUS='false'
  INSTALL_CASTLE_ENGINE='true'

  for ARGUMENT in "$@"; do
    case "$ARGUMENT" in
      --os=*)
        OS="${ARGUMENT#*=}"
        ;;
      --cpu=*)
        CPU="${ARGUMENT#*=}"
        ;;
      --castle-engine-version=*)
        CASTLE_ENGINE_VERSION="${ARGUMENT#*=}"
        ;;
      --fpc-version=stable|--fpc-version=unstable)
        # Call this FPC_VERSION_LABEL, not FPC_VERSION, for consistency with build_fpc script.
        FPC_VERSION_LABEL="${ARGUMENT#*=}"
        ;;
      --install-castle-engine=true|--install-castle-engine=false)
        # In case user passes other arguments, like --castle-engine=yes, let it fallback to default error
        INSTALL_CASTLE_ENGINE="${ARGUMENT#*=}"
        ;;
      --install-fpc=true|--install-fpc=false)
        INSTALL_FPC="${ARGUMENT#*=}"
        ;;
      --install-lazarus=true|--install-lazarus=false)
        INSTALL_LAZARUS="${ARGUMENT#*=}"
        ;;
      *)
        echo "Unknown argument: $ARGUMENT"
        exit 1
        ;;
    esac
  done

  # apply defaults
  if [ -z "${CASTLE_ENGINE_VERSION:-}" ] ; then
    CASTLE_ENGINE_VERSION='snapshot'
  fi

  if [ -z "${FPC_VERSION_LABEL:-}" ] ; then
    FPC_VERSION_LABEL='stable'
  fi

  if [ -z "${OS:-}" ] ; then
    case "`uname -s`" in
      Linux) OS='linux' ;;
      Darwin) OS='darwin' ;;
      # see https://github.com/conan-io/conan/issues/4312 , also MINGW64_NT is possible
      CYGWIN* | MINGW* | MSYS*) OS='win64' ;; # by default choose 64-bit windows
      FreeBSD) OS='freebsd' ;;
      *)
        echo "Unknown OS: `uname -s`"
        exit 1
        ;;
    esac
  fi

  if [ -z "${CPU:-}" ] ; then
    case "`uname -m`" in
      x86_64) CPU='x86_64' ;;
      i686) CPU='i386' ;;
      # Raspberry Pi 64 reports aarch64 .
      # macOS on Apple Silicon reports arm64 .
      aarch64|arm64) CPU='aarch64' ;;
      armv7l) CPU='arm' ;;
      *)
        echo "Unknown CPU: `uname -m`"
        exit 1
        ;;
    esac
  fi
}

# Determine variables used in the rest of the script.
do_setup_environment()
{
  # calculate WORKSPACE_ROOT and WORKSPACE_ROOT_UNIX.
  # On Windows they differ:
  # - WORKSPACE_ROOT_UNIX is in Cygwin path format (with /, without :, more suitable for $PATH)
  # - WORKSPACE_ROOT is in native (on Windows) path format, understood also by non-Msys2/Cygwin tools
  WORKSPACE_ROOT_UNIX="`pwd`"
  WORKSPACE_ROOT="${WORKSPACE_ROOT_UNIX}"
  if which cygpath > /dev/null; then
    WORKSPACE_ROOT="`cygpath --mixed \"${WORKSPACE_ROOT}\"`"
  fi

  DEFINES_FILE="${WORKSPACE_ROOT}/setup_castle_engine_env.sh"

  echo "Variables calculated:"
  echo "  OS: ${OS}"
  echo "  CPU: ${CPU}"
  echo "  CASTLE_ENGINE_VERSION: ${CASTLE_ENGINE_VERSION}"
  echo "  WORKSPACE_ROOT: ${WORKSPACE_ROOT}"
  echo "  WORKSPACE_ROOT_UNIX: ${WORKSPACE_ROOT_UNIX}"
  echo "  DEFINES_FILE: ${DEFINES_FILE}"
  echo
}

# Just in case, enable multiple runs of this script, by cleaning up
# at the beginning.
do_cleanup()
{
  rm -Rf fpc/ castle-engine/ "${DEFINES_FILE}"
}

# Get FPC from castle-fpc
do_get_fpc()
{
  echo '-------------------------------------------------------------------'
  echo 'Setting up FPC'

  # calculate ZIP_NAME
  case "${FPC_VERSION_LABEL}" in
    stable)
      local FPC_VERSION_TO_ZIP=''
      ;;
    unstable)
      local FPC_VERSION_TO_ZIP='unstable-'
      ;;
    *)
      echo "Unknown FPC version: ${FPC_VERSION_LABEL}"
      exit 1
    ;;
  esac
  local ZIP_NAME="fpc-${FPC_VERSION_TO_ZIP}${OS}-${CPU}.zip"

  # Using --progress=... below because default wget progress
  # (default or --progress=dot) causes hard to read output in GHA logs.
  # Using --output-document because by default, wget adds suffix when file exists,
  # placing it under new name.
  wget --progress=bar:force:noscroll \
    "https://github.com/castle-engine/castle-fpc/releases/download/snapshot/${ZIP_NAME}" \
    --output-document castle-fpc.zip

  # Use -q for more readable output in logs.
  unzip -q castle-fpc.zip

  # Use PPC_CONFIG_PATH to provide custom fpc.cfg
  # in a way that is cross-platform (otherwise, we'd need to use ~/.fpc.cfg
  # on Unix, fpc/bin/ on Windows) and that doesn't mess with any user/system-wide
  # fpc.cfg (so e.g. we don't touch ~/.fpc.cfg on user's machine).

  export PPC_CONFIG_PATH="${WORKSPACE_ROOT}/fpc"
  preserve_variable_for_future_ci_steps PPC_CONFIG_PATH
  FPC_CFG="${PPC_CONFIG_PATH}/fpc.cfg"

  # Define fpc.cfg following https://github.com/castle-engine/castle-fpc docs
  echo '# Minimal fpc.cfg for FPC from https://github.com/castle-engine/castle-fpc' > "${FPC_CFG}"
  echo "-Fu${WORKSPACE_ROOT}/fpc/units/\$FPCTARGET/*" >> "${FPC_CFG}"

  # Add macOS specific flags, see castle-fpc/README.md for reasons.
  # Otherwise, linking on newer macOS versions fails.
  if [ "$OS" = "darwin" ] ; then
    MAC_SDK="`xcrun --show-sdk-path`"
    MAC_XCODE="`xcode-select --print-path`"
    # Typical results:
    # MAC_SDK=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk
    # MAC_XCODE=/Applications/Xcode.app/Contents/Developer

    echo "-XR${MAC_SDK}" >> "${FPC_CFG}"
    echo "-Fl${MAC_SDK}/usr/lib" >> "${FPC_CFG}"
    echo "-FD${MAC_XCODE}/Toolchains/XcodeDefault.xctoolchain/usr/bin" >> "${FPC_CFG}"

    # Linking on newer macOS, with Aarch64, requires -WMxxx (it is also OK on x86_64).
    # See also fpcupdeluxe logic:
    # https://github.com/LongDirtyAnimAlf/fpcupdeluxe/blob/63228f718e24e0a5e77c8f5b70e269ba92393b9d/sources/crossinstallers/m_darwin_to_apple_base.pas#L232
    # Some discussion in:
    # https://gitlab.com/freepascal.org/lazarus/lazarus/-/issues/41570
    MAC_SDK_VERSION="`xcrun --show-sdk-version`"
    echo "SDK version is ${MAC_SDK_VERSION}, assuming it is >= 11.0"
    echo "-WM10.15" >> "${FPC_CFG}"
  fi

  echo "Defined FPC config in ${FPC_CFG}:"
  echo "==================================================================="
  cat "${FPC_CFG}"
  echo "==================================================================="

  prepend_to_path "${WORKSPACE_ROOT}/fpc/bin"

  echo "FPC version info:"
  fpc -iV # version
  fpc -iTO # target os
  fpc -iTP # target cpu
}

# Get Castle Game Engine
do_get_castle_engine()
{
  echo '-------------------------------------------------------------------'
  echo 'Setting up Castle Game Engine'

  export CASTLE_ENGINE_PATH="${WORKSPACE_ROOT}/castle-engine"
  preserve_variable_for_future_ci_steps CASTLE_ENGINE_PATH

  prepend_to_path "${WORKSPACE_ROOT}/castle-engine/tools/build-tool/"

  git clone --depth 1 --single-branch \
    --branch "${CASTLE_ENGINE_VERSION}" \
    https://github.com/castle-engine/castle-engine/

  cd $CASTLE_ENGINE_PATH/tools/build-tool/
  ./castle-engine_compile.sh
}

# Install Lazarus from https://github.com/castle-engine/castle-lazarus/
do_get_lazarus()
{
  echo '-------------------------------------------------------------------'
  echo 'Setting up Lazarus'

  # See do_get_fpc for reasons behind wget and unzip flags.
  wget --progress=bar:force:noscroll \
    https://github.com/castle-engine/castle-lazarus/releases/download/snapshot/lazarus-${OS}-${CPU}.zip \
    --output-document lazarus.zip
  unzip -q lazarus.zip

  # We want to point lazbuild to the Lazarus location.
  #
  # - Create wrapper that calls lazbuild with --pcp= ?
  #   Valid idea, but if the wrapper is shell script, it will not work
  #   out-of-the-box on Windows where Windows-native applications call lazbuild
  #   (that would need to call "bash lazbuild-wrapper.sh").
  #   We could make wrapper in Pascal, but this seems more complicated than it should.

  # - Using LAZARUSDIR?
  #   Alas, it doesn't work, as our tests show, despite LAZARUSDIR being
  #   properly defined. Lazarus code uses LAZARUSDIR, but maybe lazbuild
  #   does not execute that.
  #
  #     export LAZARUSDIR="${WORKSPACE_ROOT}/lazarus"
  #     preserve_variable_for_future_ci_steps LAZARUSDIR
  #
  # - Using lazarus.cfg?
  #
  #   Lazarus command-line code has code to determine
  #   lazbuild[.exe] location even on Unix (where ParamStr(0) is reliable).
  #   See ProgramDirectory in components/lazutils/fileutil.inc, which does a simple hack,
  #   and just looks for itself on $PATH .
  #   It is used to determine lazarus.cfg .
  #
  #   See https://wiki.lazarus.freepascal.org/Multiple_Lazarus#Using_lazarus.cfg_file
  #   about lazarus.cfg .
  #
  #   The Lazarus code in lazarus/ide/idecmdline.pas
  #   suggests it should also use --lazarusdir in lazarus.cfg but this fails
  #   for lazbuild. What works is pointing --primary-config-path to a config
  #   that has environmentoptions.xml ,
  #   that then points to Lazarus directory... long way round.

  cat <<EOF > lazarus/lazarus.cfg
--primary-config-path=${WORKSPACE_ROOT}/lazarus_config
EOF

  mkdir -p lazarus_config
  cat <<EOF > lazarus_config/environmentoptions.xml
<?xml version="1.0" encoding="UTF-8"?>
<CONFIG>
  <EnvironmentOptions>
    <Version Lazarus="3.4" Value="110"/>
    <LazarusDirectory Value="${WORKSPACE_ROOT}/lazarus">
    </LazarusDirectory>
  </EnvironmentOptions>
</CONFIG>
EOF

  # put "lazbuild" on $PATH
  prepend_to_path "${WORKSPACE_ROOT}/lazarus"

  # This subdirectory is unnecessary, and it prevents running "install"
  # in certain situations ("install" from CGE Makefile).
  # Looks like bash is smart to not find directories in $PATH,
  # but GNU make it not that smart.
  rm -Rf lazarus/install
}

# ----------------------------------------------------------------------------
# main: call functions

do_parse_arguments "$@"
do_setup_environment
do_cleanup
if [ "$INSTALL_FPC" = 'true' ] ; then
  do_get_fpc
fi
if [ "$INSTALL_LAZARUS" = 'true' ] ; then
  do_get_lazarus
fi
if [ "$INSTALL_CASTLE_ENGINE" = 'true' ] ; then
  do_get_castle_engine
fi
