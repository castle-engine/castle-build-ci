#!/usr/bin/env bash
set -euo pipefail

# ------------------------------------------------------------------------------
# Sign and notarize the app bundle.
#
# Codesigning follows
# https://developer.apple.com/documentation/xcode/creating-distribution-signed-code-for-the-mac
# Notarization follows
# https://developer.apple.com/documentation/security/customizing-the-notarization-workflow?language=objc
#
# Options:
# $1 is bundle directory (like "castle-model-viewer.app")
# $2 is main executable name (like "castle-model-viewer")
#
# Before using this script, sign *all but the main executables* inside
# the bundle using sign_executable script. This follows Apple rules to
# "sign from the innermost files".
# You can usually ignore this -- most normal applications have just one
# binary file inside the bundle.
# ------------------------------------------------------------------------------

BUNDLE="$1"
MAIN_EXE="$2"
shift 2

# error if excessive command-line parameters
if [[ $# -ne 0 ]]; then
  echo "Codesigning error: Excessive command-line parameters. Usage: $0 BUNDLE MAIN_EXE"
  exit 1
fi

echo '-------------------------------'
echo 'Checking is our APPLE_IDENTITY valid (should be in the keychain):'
security find-identity -p codesigning -v
if ! security find-identity -p codesigning -v | grep --fixed-strings "$APPLE_IDENTITY" > /dev/null; then
  echo 'Codesigning error: APPLE_IDENTITY not found in the keychain'
  exit 1
fi

echo '-------------------------------'
echo 'Signing the app bundle:'
# command below should sign the main executable
codesign -s "$APPLE_IDENTITY" --timestamp -o runtime "${BUNDLE}"

echo '-------------------------------'
echo 'Checking validity of the signed app bundle (without --deep):'

# Run codesign with all indicated arguments $@.
# Also check does the result contain lines Authority=...
# that indicate this was properly signed.
check_codesign()
{
  codesign "$@"
  REQUIRED_AUTHORITY="Authority=${APPLE_IDENTITY}"
  if ! codesign "$@" 2>&1 | grep --fixed-strings "$REQUIRED_AUTHORITY" > /dev/null; then
    echo 'Codesigning validation error: Failed to find authority ${REQUIRED_AUTHORITY}, consult above output for details'
    exit 1
  fi
  REQUIRED_AUTHORITY="Authority=Developer ID Certification Authority"
  if ! codesign "$@" 2>&1 | grep --fixed-strings "$REQUIRED_AUTHORITY" > /dev/null; then
    echo 'Codesigning validation error: Failed to find authority ${REQUIRED_AUTHORITY}, consult above output for details'
    exit 1
  fi
  REQUIRED_AUTHORITY="Authority=Apple Root CA"
  if ! codesign "$@" 2>&1 | grep --fixed-strings "$REQUIRED_AUTHORITY" > /dev/null; then
    echo 'Codesigning validation error: Failed to find authority ${REQUIRED_AUTHORITY}, consult above output for details'
    exit 1
  fi
}

check_codesign -d -vv "${BUNDLE}"
check_codesign -d -vv "${BUNDLE}/Contents/MacOS/${MAIN_EXE}"

echo '-------------------------------'
echo 'Checking validity of the signed app bundle (with --deep):'
check_codesign -d -vv --deep "${BUNDLE}"

# Note that Apple notarization process is seriously FUBAR.
# We need to create a temporay zip with app bundle (because "notarytool submit"
# wants zip, not app bundle),
# but then we need to "staple" the app bundle (*not* zip),
# and only later we can make proper release zip.

echo '-------------------------------'
echo 'Notarizing the app bundle:'

# create temporary zip for notarization submission
# Note: This could exclude, in the future, application data.
# Notarization only actually looks at executables in the application bundle,
# though we have to "staple" whole bundle.
rm -f temp-notarize.zip
zip -r temp-notarize.zip "${BUNDLE}/"
xcrun notarytool submit temp-notarize.zip \
  --apple-id "$APPLE_ID" \
  --password "$APPLE_APP_PASSWORD" \
  --team-id "$APPLE_TEAM_ID" \
  --wait
rm -f temp-notarize.zip

echo '-------------------------------'
echo 'Stapling the app bundle:'
xcrun stapler staple "${BUNDLE}"
